
struct listnode{
    int val;
    struct listnode *next;
};
//方法1：迭代反转链表。
struct listnode* reverselist(struct listnode* head){
    if(head==NULL || haed->next==NULL)                   //只有一个或0个的情况。
        return head;
    struct listnode* n1=NULL,*n2=head,*n3=head->nextl;   //在链表头之前加一个空指针n1,链表头为n2,第二个节点为n3.
    while(n2)                                            //n2为空时，n1为链表尾，已经结束不用继续。
    {
        n2->next=n1;                                     //先将n1,n2反转。
        n1=n2;                                           //n3的作用是储存下一个节点，不然n1,n2反转后会丢失下一个节点的地址。
        n2=n3;                                           //再将三个地址都向后挪动一位，重复操作。
        if(n3)                                           //如果n3为空则不含next，程序报错。
            n3=n3->next;
    }
};
//方法2：用一个新链表反转链表。
struct listnode* reverselist(struct listnode* head){
    struct listnode* newhead=NULL;
    struct listnode* cur=head;
    while(cur)                           //当前链表头为空则结束。这样可以很好的解决当前链表为空或者next->next为空的问题（方法1出现的问题）。
    {
        struct listnode* next=cur->next; //赋值next来储存当前链表的第二个节点，防止当前链表头移动之后丢失第二个节点地址。
        cur->next=newhead;                //将当前链表头移动到新链表头的前面，即头插。
        newhead=cur;                      //重新赋值新链表头。
        cur=next;                         //重新赋值当前链表头。
    }
    return newhead;
}
