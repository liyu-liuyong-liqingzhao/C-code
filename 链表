
struct listnode{
    int val;
    struct listnode *next;
};
//方法1：迭代反转链表。
struct listnode* reverselist(struct listnode* head){
    if(head==NULL || haed->next==NULL)                   //只有一个或0个的情况。
        return head;
    struct listnode* n1=NULL,*n2=head,*n3=head->nextl;   //在链表头之前加一个空指针n1,链表头为n2,第二个节点为n3.
    while(n2)                                            //n2为空时，n1为链表尾，已经结束不用继续。
    {
        n2->next=n1;                                     //先将n1,n2反转。
        n1=n2;                                           //n3的作用是储存下一个节点，不然n1,n2反转后会丢失下一个节点的地址。
        n2=n3;                                           //再将三个地址都向后挪动一位，重复操作。
        if(n3)                                           //如果n3为空则不含next，程序报错。
            n3=n3->next;
    }
};
//方法2：用一个新链表反转链表。
struct listnode* reverselist(struct listnode* head){
    struct listnode* newhead=NULL;
    struct listnode* cur=head;
    while(cur)                           //当前链表头为空则结束。这样可以很好的解决当前链表为空或者next->next为空的问题（方法1出现的问题）。
    {
        struct listnode* next=cur->next; //赋值next来储存当前链表的第二个节点，防止当前链表头移动之后丢失第二个节点地址。
        cur->next=newhead;                //将当前链表头移动到新链表头的前面，即头插。
        newhead=cur;                      //重新赋值新链表头。
        cur=next;                         //重新赋值当前链表头。
    }
    return newhead;
}

struct listnode* middle(struct listnode* head)
{//只遍历一遍就找出链表中间结点（偶数为第二个）
    struct listnode* slow=head;
    struct listnode* fast=head;
    while(fast && fast->next)//这里为且，因为while判断的是继续的条件而不是结束的条件。
    {
        slow=slow->next;
        fast=fast->next->next;
    }
    return slow;
};

struct listnode* find(struct listnode* head,int k)
{//只遍历一遍就找出链表倒数第k个结点。
    struct listnode* slow=head;
    struct listnode* fast=head;
    while(k--)
    {//先让fast走k步，再一起运动到尾。
        if(fast)//防止k大于链表长度时出现段错误。
            fast=fast->next;
        else
            return NULL;
    }
    while(fast)
    {
        slow=slow->next;
        fast=fast->next;
    }
    return slow;
};

struct listnode* together(struct listnode* list1,struct listnode* list2)
{//合并两个升序链表为一个新的升序链表，要求由两个链表拼接而来。
    if(list1==NULL)
        return list2;
    if(list2==NULL)
        return list1;
    struct listnode* head=NULL;
    struct listnode* tail=NULL;//记录拼接的链表的尾，以便于直接尾插，不用再遍历链表找到尾。
    if(list1->val < list2->val)//还可以不写if和else，设置带哨兵位的头结点，不储存数据，只便于尾插。
    {                          //写成head=tail=(struct listnode*)malloc(sizeof(struct listnode));
        head=tail=list1;       //结尾将return head改为struct listnode* newhead=head->next;
        list1=list1->next;                          //free(head);
    }                                               //return newhead;
    else
    {
        head=tail=list2;
        list2=list2->next;
    }
    while(list1 && list2)
    {
        if(list1->val < list2->val)
        {
            tail
        }
    }
    if(list1)
        tail->next=list1;
    else
        tail->next=list2;
    return head;
};

bool checklist(listnode* A){
//bool函数只返回ture或false.
//判断一个链表的值是否是回文结构，时间复杂度O(n)空间复杂度O(1).
    listnode* fast = A;//先找出中间结点(偶数为后一个)，取下来作一个新链表，
    listnode* slow = A;//再逆置之后判断两个链表是否相等。
    listnode* prev = NULL;//取下来逆置之前slow的前一个指针仍指向slow.
    while(fast && fast->next)
    {
        prev=slow;
        slow=slow->next;
        fast=fast->next->next;
    }
    prev->next=NULL;  //逆置后仍指向slow(新链表的尾),此处将它们断开。
    slow=reverselist(slow);//逆置链表，此处省略，逆置会返回新链表的头(不是slow,而是新的地址，所以需要赋值给slow。
    while(A)//可能会有一个链表多出一个，但是只要短的结束时都相同就满足。
    {
        if(A->val != slow->val)
        {
            return false;
        }
        else
        {
            A=A->next;
            slow=slow->next;
        }
    }
    return true;
}
