#include<stdio.h>
int main(){
    char arr0[]="abcd";
    printf("%s",arr0);    //%s打印字符串,arr表示首元素地址。

    char arr1[]="a";
    char arr2[]="a";
    if(arr1==arr2)       //不会输出1，因为数组名代表首元素地址，创建两个数组相当于创建两块空间，
        printf("%d",1);  //首元素地址自然不相同，所以if不成立。
    char* p1="b";
    char* p2="b";
    if(p1==p2)           //p1和p2都代表首元素的地址，只是指向这块已存在空间的首元素地址，
        printf("%d",2);  //结果相同，因此if成立。

    int arr=[5];       //5个int型元素的数组。
    int *p1[5];        //5个int型指针元素的数组。
    int (*p2)[5];      //指向5个int型元素数组的指针。
    int (*p3[10])[5];  //10个指向5个int型元素数组的指针组成的数组，相当于10个p2组成的数组。

    int a[4]={1,2,3,4};
    int* p1=(int*)(&a+1);
    int* p2=(int*)((int)a+1);      //强制转化为整数后+1，即地址向后移动一个字节，地址以小端储存（反向），
                                   //01 00 00 00 | 02 00 00 00，p2表示01向后一个字节的地址，int*访问4个字节，
                                   //即访问00 00 00 02，小端储存输出时需要恢复，即输出02 00 00 00.
    printf("%x,%x",p1[-1],*p2);    //%x表示以16进制数输出，p1[-1]表示*(p1-1)，
                                   //第一个输出4，第二个输出2000000.

    int a[5][5];
    int(*p)[4];
    p=a;   //a表示首元素地址，即第一行的一维数组地址，5个元素，而p是数组指针，指向4个元素，因此会报出警告，但不影响程序。这时p表示一行第一个元素地址。
    printf("%p,%d",&p[4][2]-&a[4][2],&p[4][2]-&a[4][2]);//a[4][2]是五行第三个元素，而p[4][2]表示*(*(p+4)+2).
                                                        //p指向4个元素，p+4跳过16个元素(a每行5个元素)，表示4行第二个元素地址，再+2指向4行第四个元素。
                                                        //因此相差4个元素，-4以补码储存，%p输出地址，不考虑符号位，直接将二进制补码当做地址，
                                                        //地址以16进制输出，二进制4个1转化为F,而最后4位1100转化为C,
                                                        //第一个输出0xFFFFFFFC，第二个输出-4.
    
    char* c[]={"enter","new","point","first"};          //c中储存每个单词首字母的地址，
    char**cp[]={c+3,c+2,c+1,c};                         //注意cp中是反过来储存的,
    char***cpp=cp;                                      //cpp指向cp首元素地址，即c+3.
    printf("%s",**++cpp);          //cpp+1指向c+2，两次解引用得到p的地址，输出字符point.
    printf("%s",*--*++cpp+3);      //cpp的值已经改变，再+1得到c+1的地址，解引用得到c+1，c+1-1得到c(不是地址-1)，解引用得到e的地址，+3向后3个字节，得到e的地址，输出er.
    printf("%s",*cpp[-2]+3);       //cpp仍是c+1地址，cpp[-2]=*(cpp-2),cpp-2得到c+3的地址，两次解引用(中括号等效一次解引用)得到f的地址，再向后3个字节得到s地址，输出st.
    printf("%s",cpp[-1][-1]+1);    //cpp仍是c+1地址，cpp[-1][-1]+1=*(*(cpp-1)-1)+1，cpp-1得到c+2地址，解引用得到c+2再-1得到c+1(不是地址-1)，解引用得到n地址再向后1个字节，输出ew.
    
    void* a;
    ++(char*)a;  //void*不能进行地址运算，因为不能判断一次操作几个字节，所以需要强制类型转换，但是++的优先级高于（char*），所以++要前置，不能写成（char*）a++.
    
    return 0;
    }
