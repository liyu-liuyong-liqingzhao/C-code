#include<stdio.h>
int main(){
    char arr0[]="abcd";
    printf("%s",arr0);    //%s打印字符串,arr表示首元素地址。

    char arr1[]="a";
    char arr2[]="a";
    if(arr1==arr2)       //不会输出1，因为数组名代表首元素地址，创建两个数组相当于创建两块空间，
        printf("%d",1);  //首元素地址自然不相同，所以if不成立。
    char* p1="b";
    char* p2="b";
    if(p1==p2)           //p1和p2都代表首元素的地址，只是指向这块已存在空间的首元素地址，
        printf("%d",2);  //结果相同，因此if成立。

    int arr=[5];       //5个int型元素的数组。
    int *p1[5];        //5个int型指针元素的数组。
    int (*p2)[5];      //指向5个int型元素数组的指针。
    int (*p3[10])[5];  //10个指向5个int型元素数组的指针组成的数组，相当于10个p2组成的数组。

    int a[4]={1,2,3,4};
    int* p1=(int*)(&a+1);
    int* p2=(int*)((int)a+1);      //强制转化为整数后+1，即地址向后移动一个字节，地址以小端储存（反向），
                                   //01 00 00 00 | 02 00 00 00，p2表示01向后一个字节的地址，int*访问4个字节，
                                   //即访问00 00 00 02，小端储存输出时需要恢复，即输出02 00 00 00.
    printf("%x,%x",p1[-1],*p2);    //%x表示以16进制数输出，p1[-1]表示*(p1-1)，
                                   //第一个输出4，第二个输出2000000.

    int a[5][5];
    int(*p)[4];
    p=a;   //a表示首元素地址，即第一行的一维数组地址，5个元素，而p是数组指针，指向4个元素，因此会报出警告，但不影响程序。这时p表示一行第一个元素地址。
    printf("%p,%d",&p[4][2]-&a[4][2],&p[4][2]-&a[4][2]);//a[4][2]是五行第三个元素，而p[4][2]表示*(*(p+4)+2).
                                                        //p指向4个元素，p+4跳过16个元素(a每行5个元素)，表示4行第二个元素地址，再+2指向4行第四个元素。
                                                        //因此相差4个元素，-4以补码储存，%p输出地址，不考虑符号位，直接将二进制补码当做地址，
                                                        //地址以16进制输出，二进制4个1转化为F,而最后4位1100转化为C,
                                                        //第一个输出0xFFFFFFFC，第二个输出-4.
    return 0;
    }
